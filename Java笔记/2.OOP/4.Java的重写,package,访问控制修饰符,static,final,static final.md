# Java的重写,package,访问控制修饰符,static,final,static final #

## **1.方法的重写(Override):重新写、覆盖**
  1. 发生在父子类中,方法名称相同,参数列表相同,方法体不同  
  2. 重写方法被调用时,看对象的类型  

## **2.重写与重载的区别**


 - 重写(Override):
    1. 发生在父子类中,方法名称相同,参数列表相同,方法体不同,返回值相同  
    1. 遵循"运行期绑定",看对象的类型调用参数

 - 重载(Overload)

    1. 发生在同一类中,方法名称相同,参数列表不同,方法体不同,返回值不一定
    1. 遵循"编译器绑定",看引用的类型绑定方法


 - 重写要遵循"两同两小一大"原则

    - 两同:  
       - 方法名相同  
     	- 参数列表相同
    - 两小  
     	- void时,必须相同  
     	- 基本类型时,必须相同  
       - 引用类型时,小于或等于

    - 一大  
     	- 子类方法的访问权限大于或等于父类

## **3.package**
  1. 作用:避免类的命名冲突
  2. 包一般都是有层次结构的
  3. 类名的全称为:包名.类名
  4. 建议:包名所有字母都小写  




-  import
 1. 先import声明类再直接访问---建议
   2. 类的全称--繁琐

## **4.访问控制修饰符**

  1. public:**公开的,任何类**
  2. private:**私有的,本类**
  3. protected:**受保护的,本类、子类、同包类**
  4. 默认的:**什么也不写,本类,同包类**

 	类的访问修饰符为:public和默认的  
 	类中的成员的访问修饰符为:以上四种都可以


## **5.static静态**



 - 静态变量  

  1. 由static修饰
  2. 属于类,存在方法区中,只有一份
  3. 常常通过类名来访问
  4. 何时用:所有对象共享的数据(图片、音频、视频)

 - 静态方法

   1. 由static修饰
   2. 属于类,存在 方法区,只有一份
   3. 常常通过类名.来访问
   4. 静态方法没有隐式的this传递  
 	所以静态方法中不能直接访问实例成员,但是利用访问
   5. 何时用:方法的操作仅与参数相关而与对象无关
 - 静态块

  1. 属于类的,在类被加载期间自动执行  
 	因类只能加载一次,所以静态块也只执行一次  

  1. 何时用:常常用于加载/初始化静态资源(图片、音频、视频)

## **6.final:最终的、补课改变的**

  1. 修饰变量:变量不可被改变
  2. 修饰方法:方法不可被重写
  3. 修饰类:类不可被继承 ,但是可以继承其他类 (不能当老大)  
  final修饰局部变量,用之前初始化即可

## **7.static final常量**

 - static final修饰的成员变量称为常量，必须声明同时初始化，不可以被改变  
 - static final常量会在编译期被替换

```java
    class Foo{
    	public static final int NUM = 100;
    }

    class Goo{
    	public static void main(String[] args){
    		System.out.println(Foo.NUM);
    		//代码编辑时,会替换为 System.out.println(100);
    	}
    }
```
 **static final 常量Foo.NUM会在编译期时被替换为其常量值(100),
 在运行Goo类时,Foo类不需要被载入**





- static final 静态常量  
   1. 常量必须声明同时初始化  
   2. 通过类名点来访问，不能改变  
   3. 建议:常量名所有字母都大写，多个单词用_分隔  
   4. 常量在编译时被直接替换为具体的值----效率高  
